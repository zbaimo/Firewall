# 核心概念详解

## 指纹与身份链系统

这是本系统最核心的创新设计，用于追踪和识别攻击者的行为演变。

### 1. 基础指纹 (Base Fingerprint)

**定义**：基于 `IP地址 + User-Agent` 生成的SHA256哈希值

**作用**：识别"相同的设备/客户端"

**示例**：
```
IP: 192.168.1.100
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0

→ base_hash: a1b2c3d4e5f6... (64字符)
```

**关键点**：
- 同一IP使用同一浏览器 = 相同的基础指纹
- 换IP或换浏览器 = 不同的基础指纹

### 2. 行为指纹 (Behavior Fingerprint)

**定义**：基于请求特征生成的哈希值

**包含字段**：
- 请求方法 (GET/POST/etc)
- 请求路径 (规范化后)
- 状态码
- 是否有查询参数
- Referer存在与否

**示例**：
```
请求: GET /api/users?page=1
状态: 200
有Referer: true

→ behavior_hash: x9y8z7w6v5u4... (64字符)
```

**关键点**：
- 相似的请求模式 = 相似的行为指纹
- 路径扫描、注入攻击 = 明显不同的行为指纹

### 3. 身份链 (Identity Chain)

**核心思想**：像"姓氏"一样关联演变的指纹

#### 为什么需要身份链？

**传统问题**：
- 攻击者初期用正常浏览器刺探
- 后期切换到攻击工具
- IP相同但User-Agent改变
- 系统无法关联这是同一个攻击者

**我们的解决方案**：
```
阶段1: IP=1.2.3.4 + Chrome → base_hash_A (正常浏览)
阶段2: IP=1.2.3.4 + sqlmap → base_hash_B (攻击)

传统系统：两个独立的访问者
我们的系统：检测到IP相同 → 创建身份链 → 关联A和B
```

#### 身份链创建条件

在 `config.yaml` 中配置：
```yaml
fingerprint:
  identity_chain_threshold:
    same_base_count: 10      # 相同基础指纹出现10次
    behavior_change_rate: 0.3  # 行为变化率超过30%
```

**触发逻辑**：
1. 统计某个基础指纹的所有访问
2. 计算有多少种不同的行为指纹
3. 行为多样性 = 不同行为数 / 总访问数
4. 如果 访问数≥10 且 多样性≥0.3 → 创建身份链

#### 身份链数据结构

```json
{
  "id": 1,
  "root_hash": "新生成的父哈希",
  "evolution_history": [
    {
      "hash": "base_hash_A",
      "timestamp": "2025-01-01 10:00:00",
      "reason": "behavior_evolution_detected",
      "unique_behaviors": 5,
      "behavior_diversity": 0.35
    },
    {
      "hash": "base_hash_B", 
      "timestamp": "2025-01-01 15:00:00",
      "reason": "behavior_continued_evolution",
      "unique_behaviors": 12,
      "behavior_diversity": 0.55
    }
  ],
  "fingerprint_count": 2,
  "total_visits": 150,
  "threat_score": 85
}
```

### 4. 完整工作流程

```
┌─────────────────────────────────────────────────────┐
│ 1. 日志进入                                          │
│    IP: 192.168.1.100                                │
│    UA: Chrome                                        │
│    Path: /api/users                                 │
└──────────────────┬──────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────────┐
│ 2. 生成指纹                                          │
│    base_hash = sha256(IP + UA)                      │
│    behavior_hash = sha256(method + path + ...)      │
└──────────────────┬──────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────────┐
│ 3. 存储到数据库                                      │
│    access_logs 表                                    │
│    fingerprints 表（更新或创建）                     │
└──────────────────┬──────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────────┐
│ 4. 行为分析                                          │
│    查询该base_hash的历史记录                         │
│    计算行为多样性                                    │
│    判断是否达到身份链创建条件                        │
└──────────────────┬──────────────────────────────────┘
                   ↓
           ┌───────┴───────┐
           │               │
    [需要创建]        [不需要创建]
           │               │
           ↓               ↓
┌──────────────────┐  ┌──────────┐
│ 5. 创建身份链     │  │ 继续监控  │
│    生成root_hash │  └──────────┘
│    关联所有指纹   │
└──────────────────┘
           ↓
┌─────────────────────────────────────────────────────┐
│ 6. 后续访问                                          │
│    自动归档到身份链                                  │
│    更新威胁评分                                      │
│    触发告警（如果需要）                              │
└─────────────────────────────────────────────────────┘
```

## 实际案例分析

### 案例1：渗透测试者的行为演变

**时间线**：
```
Day 1, 10:00 - 正常访问
  IP: 203.0.113.45
  UA: Chrome/120.0
  行为: 访问首页、登录页
  → base_hash_1 创建

Day 1, 10:30 - 继续正常访问  
  访问了10次不同页面
  行为多样性: 0.2 (正常)

Day 1, 14:00 - 开始异常
  突然访问 /.env, /.git, /admin
  行为多样性提升到 0.4
  → 触发身份链创建！

Day 1, 15:00 - 切换工具
  UA变为: sqlmap/1.6
  → 生成新的base_hash_2
  → 但IP相同，系统检测到
  → base_hash_2 加入到身份链

Day 1, 16:00 - 再次切换
  UA变为: nikto/2.1.5  
  → base_hash_3 也加入身份链

最终结果：
  identity_chain #1
    ├─ base_hash_1 (Chrome)
    ├─ base_hash_2 (sqlmap)
    └─ base_hash_3 (nikto)
  
  威胁评分: 95/100
  状态: 已封禁
  原因: 行为演变 + 多工具攻击
```

### 案例2：正常用户的行为

**时间线**：
```
持续1周的访问
  IP: 192.168.1.10
  UA: Safari (固定)
  行为: 访问相似页面
  
统计:
  总访问: 500次
  不同行为: 5种
  行为多样性: 0.01 (非常低)
  
结果:
  → 未创建身份链（正常用户）
  → 威胁评分: 0
  → 状态: 正常
```

### 案例3：分布式攻击

**场景**：多个IP协同攻击

```
IP_1, IP_2, IP_3 ... IP_10
  相同的攻击模式
  相同的User-Agent: python-requests
  访问相同的敏感路径
  
系统响应:
  1. 每个IP创建独立的指纹
  2. 检测到相似的行为模式
  3. 可选: 手动合并身份链
     python tools/cli_manager.py merge-chains 1 2
```

## 数据库设计

### 核心表关系

```
┌─────────────────┐
│  access_logs    │  每次访问的详细记录
│  ─────────────  │
│  id             │
│  ip             │
│  base_hash      │◄────────┐
│  behavior_hash  │         │
│  identity_chain │         │
└─────────────────┘         │
                            │
┌─────────────────┐         │
│  fingerprints   │  指纹汇总统计
│  ─────────────  │         │
│  id             │         │
│  base_hash      │─────────┘
│  ip             │
│  visit_count    │
│  threat_score   │
│  identity_chain │◄────────┐
└─────────────────┘         │
                            │
┌─────────────────┐         │
│ identity_chains │  身份链
│  ─────────────  │         │
│  id             │─────────┘
│  root_hash      │
│  evolution_hist │
│  threat_score   │
└─────────────────┘
```

### 查询示例

**查找某个身份链的所有活动**：
```sql
SELECT * FROM access_logs 
WHERE identity_chain_id = 1
ORDER BY timestamp;
```

**查找威胁评分最高的身份链**：
```sql
SELECT * FROM identity_chains 
ORDER BY threat_score DESC 
LIMIT 10;
```

**统计某IP的所有指纹**：
```sql
SELECT * FROM fingerprints 
WHERE ip = '192.168.1.100';
```

## 性能考虑

### 1. 哈希计算

- SHA256计算速度：~100MB/s
- 每个请求2次哈希计算
- 影响：可忽略不计

### 2. 数据库查询

**优化策略**：
- 所有关键字段都有索引
- 复合索引：(base_hash, behavior_hash)
- 分区表（大规模部署）

**查询频率**：
- 每个请求：2次SELECT, 2次INSERT/UPDATE
- 行为分析：每10次请求触发1次（可配置）

### 3. 内存使用

**Redis缓存**（可选）：
```
- 最近访问的指纹: 10000个
- 威胁IP列表: 1000个
- 封禁列表: 持久化
```

**内存占用估算**：
- SQLite: ~100MB（100万条记录）
- Redis: ~50MB（启用缓存）
- Python进程: ~100-200MB

## 对比传统方案

| 特性 | 传统IP封禁 | 我们的系统 |
|-----|-----------|----------|
| IP更换 | 失效 | ✓ 可追踪（如果行为相似） |
| 工具切换 | 识别为新访问者 | ✓ 关联到身份链 |
| 行为演变 | 无法检测 | ✓ 核心功能 |
| 误封概率 | 较高 | ✓ 较低（基于行为） |
| 历史追溯 | 困难 | ✓ 完整演变历史 |
| 威胁评分 | 无 | ✓ 动态计算 |

## 未来扩展

### 1. 机器学习增强

- 使用ML模型预测威胁
- 自动调整检测阈值
- 异常检测算法

### 2. 更多指纹维度

- TLS指纹
- HTTP/2特征
- 时间模式分析

### 3. 协同防御

- 多服务器共享威胁情报
- 分布式身份链
- 联邦学习

### 4. 可视化增强

- 攻击时间线
- 行为演变图谱
- 威胁地图

## 总结

身份链系统的核心价值：

1. **持续追踪**：不再因为攻击者更换工具/UA而失去追踪
2. **行为关联**：基于行为而不是单一特征识别威胁
3. **历史记录**：完整记录攻击者的演变过程
4. **智能防御**：基于演变模式而不是单次行为做决策

这套系统特别适合防御：
- 高级持续性威胁 (APT)
- 多阶段渗透测试
- 变换工具的自动化攻击
- 长期的针对性攻击

